{
  "name": "newrelic",
  "version": "1.8.0",
  "author": {
    "name": "New Relic Node.js agent team",
    "email": "nodejs@newrelic.com"
  },
  "licenses": [
    {
      "type": "proprietary",
      "url": "https://raw.github.com/newrelic/node-newrelic/master/LICENSE"
    }
  ],
  "contributors": [
    {
      "name": "Saxon D'Aubin",
      "email": "saxon@newrelic.com",
      "url": "http://newrelic.com"
    },
    {
      "name": "Forrest L Norvell",
      "email": "forrest@newrelic.com",
      "url": "http://newrelic.com/"
    },
    {
      "name": "Jacob Groundwater",
      "email": "jacob@newrelic.com",
      "url": "https://newrelic.com"
    },
    {
      "name": "Wraithan",
      "email": "wmcdonald@newrelic.com",
      "url": "Chris McDonald"
    }
  ],
  "description": "New Relic agent",
  "keywords": [
    "apm",
    "performance",
    "monitoring",
    "instrumentation",
    "debugging",
    "profiling"
  ],
  "homepage": "http://github.com/newrelic/node-newrelic",
  "engines": {
    "node": ">=0.6.0"
  },
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "bunyan": "0.14.6",
    "continuation-local-storage": "^3.0.0",
    "yakaa": "^1.0.0"
  },
  "devDependencies": {
    "JSV": "~4.0.2",
    "architect": "*",
    "async": "*",
    "carrier": "*",
    "chai": "*",
    "cover": "*",
    "express": "*",
    "glob": "~3.2.9",
    "memcached": ">=0.2.8",
    "mkdirp": "*",
    "mocha": "*",
    "mongodb": "*",
    "nave": "*",
    "nock": "*",
    "node-cassandra-cql": "^0.5.0",
    "npm-license": "*",
    "proxy": "^0.2.3",
    "q": "*",
    "qx": "*",
    "redis": "*",
    "request": "*",
    "restify": "*",
    "sequelize": "*",
    "should": "*",
    "sinon": "*",
    "split": "*",
    "tap": "*",
    "wrench": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/newrelic/node-newrelic.git"
  },
  "readme": "[![npm status badge](https://nodei.co/npm/newrelic.png?stars=true&downloads=true)](https://nodei.co/npm/newrelic/)\n\n# New Relic for Node.js\n\nThis package instruments your application for performance monitoring\nwith [New Relic](http://newrelic.com).\n\nThis is a new product. You should try it in your staging or development\nenvironment first to verify it works for you.\n\nMake sure you have a [New Relic account](http://newrelic.com) before\nstarting. To see all the features, such as slow transaction traces, you will\nneed a New Relic Pro subscription (or equivalent).\n\n## Table of contents\n\n* [Getting started](#getting-started)\n* [RUM / browser timings](#browser-timings-rum--real-user-monitoring)\n* [Transactions and request naming](#transactions-and-request-naming)\n* [Configuration](#configuring-the-module)\n* [Licensing](#license)\n* [Security](#security)\n* [Contributions](#contributions)\n* [Known issues](#known-issues)\n\n## Getting started\n\n1. [Install node](http://nodejs.org/#download). For now, at least 0.8 is\n   required. Some features (e.g. error tracing) depend in whole or in\n   part on features in 0.10 and above. Development work on the module is\n   being done against the latest released non-development version of Node.\n2. Install this module via `npm install newrelic` for the application you\n   want to monitor.\n3. Copy `newrelic.js` from `node_modules/newrelic` into the root directory of\n   your application.\n4. Edit `newrelic.js` and replace `license_key`'s value with the license key\n   for your account.\n5. Add `require('newrelic');` as the first line of the app's main module.\n\nIf you wish to keep the configuration for the module separate from your\napplication, the module will look for newrelic.js in the directory referenced\nby the environment variable `NEW_RELIC_HOME` if it's set.\n\nWhen you start your app, New Relic should start up with it and start reporting\ndata that will appear within [the New Relic UI](https://rpm.newrelic.com/)\nafter a few minutes. Because the agent minimizes the amount of bandwidth it\nconsumes, it only reports data once a minute, so if you require the module in\ntests that take less than a minute to run, it won't have time to report data to\nNew Relic. The module will write its log to a file named `newrelic_agent.log`\nin the application directory. If New Relic doesn't send data or crashes your\napp, the log can help New Relic determine what went wrong, so be sure to send\nit along with any bug reports or support requests.\n\n## Browser timings (RUM / Real User Monitoring)\n\nNew Relic's instrumentation can extend beyond your application into the\nclient's browser.  The `newrelic` module can generate `<script>` headers which,\nwhen inserted into your HTML templates, will capture client-side page load\ntimes.\n\nHeaders must be manually injected, but no extra configuration is necessary to\nenable browser timings.\n\n### Basics\n\n- Insert the result of `newrelic.getBrowserTimingHeader()`\ninto your html page.\n- The browser timing headers should be placed in the beginning of your `<head>` tag.\n  - As an exception to the above, for maximum IE compatability, the results of `getBrowserTimingHeader()`\nshould be placed *after* any `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.\n- Do *not* cache the header, call it once for every request.\n\n### Example\n\nBelow is an example using `express` and `jade`; Express is a popular web\napplication framework, and `jade` is a popular template module.  Although the\nspecifics are different for other frameworks, the general approach described\nbelow should work in most cases.\n\nThe simplest way to insert browser timing headers is to pass the `newrelic`\nmodule into your template, and call `newrelic.getBrowserTimingHeader()` from\nwithin the template.\n\n*app.js:*\n\n```javascript\nvar newrelic = require('newrelic');\nvar app = require('express')();\n\n// In Express, this lets you call newrelic from within a template.\napp.locals.newrelic = newrelic;\n\napp.get('/user/:id', function (req, res) {\n  res.render('user');\n});\napp.listen(process.env.PORT);\n```\n\n*layout.jade:*\n\n```jade\ndoctype html\nhtml\n  head\n    != newrelic.getBrowserTimingHeader()\n    title= title\n    link(rel='stylesheet', href='/stylesheets/style.css')\n  body\n    block content\n```\n\nBy defaults calls to `newrelic.getBrowserTimingHeader()` should return valid\nheaders.  You can disable header generation *without* removing your template\ncode.  In your `newrelic.js` file, add the following to disable header\ngeneration.\n\n```javascript\nexports.config = {\n  // ... other config\n  browser_monitoring : {\n    enable : false\n  }\n};\n```\n\nYou can also set the environment variable `NEW_RELIC_BROWSER_MONITOR_ENABLE=false`.\n\nIt is safe to leave the header generation code in place even when you're not\nusing it.  If browser timings are disabled, or there is an error such that\nworking headers cannot be generated, the `newrelic` module will generate an\ninnocuous HTML comment.  If the `newrelic` module is disabled entirely no\ncontent will be generated.\n\n## Transactions and request naming\n\nIn order to get the most value out of New Relic for Node.js, you may have to do\na little work to help us figure out how your application is structured. New\nRelic works on the assumption that it can group requests to your application\ninto transactions, which are defined by giving one or more request paths a\nname. These names are used to visualize where your app is spending its time (in\ntransaction breakdowns), to identify slow requests, and to group scoped\nmetrics. For example, this can identify slow database queries by showing which\nrequests are spending a long time waiting on the database.\n\nIf you're using Express or Restify with their default routers and are satisfied\nwith your application being represented by those frameworks' route matchers, you\nmay not need to do anything. However, if you want more specific names than are\nprovided by your framework, you may want to use one or more of the tools\ndescribed further on.\n\nThe simplest way to tell that you need to read further in this document is if\nyou feel too many of your requests are being lumped together under the\ncatch-all name `/*`. All requests that aren't otherwise named by the module\nwill end up grouped under `/*`.\n\n### Background\n\nIf you've been working with Node for a while, you're probably accustomed to\nthinking of your application's requests in terms of raw URLs. One of the great\nthings about Node is that it makes it so easy and simple to work with HTTP, and\nthat extends to things like parsing URLs and creating your own strategies for\nnaming and routing requests for services like RESTful APIs. This presents a\nchallenge for New Relic, because we need to keep the number of names we're\ntracking small enough that we can keep the New Relic user experience snappy,\nand also so we don't overwhelm you with so much data that it's difficult for\nyou to see the problem spots in your applications. URLs are not a good fit for\nhow New Relic sees performance.\n\nAnother of Node's great strengths is that it provides a lot of tools that build\non top of the `http` module to simplify writing web services. Unfortunately,\nthat variety greatly complicates things for us, with our limited resources, and\nso we offer a few different tools to help you give us the information we need\nto provide you useful metrics about your application:\n\n* we can read the route names from the Express and Restify routers, if you're\n  using them (and as said above, for many of you, this may be all you need)\n* we offer an API for naming the current request, either with simple names or,\n  if you prefer, grouped into controllers with actions\n* and we support rules stored in your module's configuration that can mark\n  requests to be renamed or ignored based on regular expressions matched\n  against the request's raw URLs (also available as API calls)\n\nRequests are mapped to transaction names using a deterministic process:\n\n1. On an incoming request, the module creates a New Relic transaction that\n   includes the HTTP request method and other metadata. As a fallback (for use\n   in the error tracer), each transaction is named after its raw request URL.\n2. When a framework using a supported router is in use, the agent copies the\n   framework name, route path and request method onto the transaction as its\n   transaction name.\n3. Within handlers, you can make calls to the module's API to explicitly set\n   the name of the route to whatever you want, or mark the route to be ignored\n   (or explicitly not ignored, see the below discussion of rules). As noted\n   below, the last API call wins when there is more than one.\n4. When the transaction is finished (i.e. the response has been completely\n   streamed out to the client), any naming or ignoring rules you have specified\n   in your configuration are applied. **NOTE:** Older versions of the module\n   only applied these rules if nothing else had named the transaction, which\n   made using rules with router-based automatic naming impossible. You must be\n   using the latest version of New Relic to combine naming and ignoring rules\n   with naming set by the router.\n5. Finally, New Relic may have its own rules that it applies to the transaction\n   name, either because the request is for something New Relic rolls up by\n   default (i.e. static assets like images or CSS files), or because New Relic\n   is applying rules to remedy metric grouping issues.\n6. If nothing has named the transaction after steps 1-5, the transaction is\n   named `/*`, which puts that request in the undifferentiated, default bucket\n   for requests. This will typically only happen in situations where your\n   application uses either no framework, or a framework with a router that\n   isn't currently supported by New Relic.\n\nLet's go through the naming tools one at a time.\n\n### Router introspection\n\nExpress is the most popular web framework in use within the Node community, and\na number of important services are also using Restify. Both frameworks map\nroutes to handlers, and both use a similar pattern to do so: they match one or\nmore HTTP methods (e.g. `GET` or the ever-popular `OPTIONS` – let's hear it for\nCORS) along with a potentially parameterized path (e.g. `/user/:id`) or a\nregular expression (e.g.  `/^/user/([-0-9a-f]+)$/`). New Relic will capture\nboth those pieces of information in the request name. If you have support for\nslow transaction traces and have enabled `capture_params`, the transaction\ntrace will also have the request's parameters and their values attached to it.\n\nThe only important thing to know about New Relic's support for Express and\nRestify is that if you're dissatisfied with the names it comes up with, you can\nuse the API calls described below to come up with more descriptive names. Also,\nif you use a different web framework or router and would like to see support\nfor it added, please let us know.\n\n### Request naming with the module API\n\nThe API is what's handed back from `require('newrelic')`, so\n\n```javascript\nvar newrelic = require('newrelic');\n```\n\nis all you need. Please note that you still need to ensure that loading the New\nRelic module is the first thing your application does, as it needs to bootstrap\nitself before the rest of your application loads, but you can safely require\nthe module from multiple modules in your application – it will only initialize\nitself once.\n\n#### newrelic.setTransactionName(name)\n\nName the current request. You can call this function anywhere within the\ncontext of an HTTP request handler, at any time after handling of the request\nhas started, but before the request has finished. A good rule of thumb is that\nif the request and response objects are in scope, you can set the name.\n\nExplicitly calling `newrelic.setTransactionName()` will override any names set\nby Express or Restify routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last call made\nbefore the request ends wins.\n\n**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,\nnumerical IDs, or timestamps in the request names you create. If your request\nis slow enough to generate a transaction trace, that trace will contain the\noriginal URL. If you enable parameter capture, the parameters will also be\nattached to the trace. The request names are used to group requests for New\nRelic's many charts and tables, and those visualizations' value drops as the\nnumber of different request names increases. If you have 50 or so different\ntransaction names, you're probably pushing it. If you have more than a couple\nhundred, you need to rethink your naming strategy.\n\n#### newrelic.setControllerName(name, [action])\n\nName the current request using a controller-style pattern, optionally including\nthe current controller action. If the action is omitted, New Relic will include\nthe HTTP method (e.g. `GET`, `POST`) as the action. The rules for when you can\ncall `newrelic.setControllerName()` are the same as they are for\n`newrelic.setTransactionName()`.\n\nExplicitly calling `newrelic.setControllerName()` will override any names set\nby Express or Restify routes. Calls to `newrelic.setTransactionName()` and\n`newrelic.setControllerName()` will overwrite each other. The last one to run\nbefore the request ends wins.\n\nSee the above note on `newrelic.setTransactionName()`, which also applies to\nthis function.\n\n### Rules for naming and ignoring requests\n\nIf you don't feel like putting calls to the New Relic module directly into your\napplication code, you can use pattern-based rules to name requests. There are\ntwo sets of rules: one for renaming requests, and one to mark requests to be\nignored by New Relic.\n\nIf you're using socket.io, you will have a use case for ignoring rules right\nout of the box. You'll probably want to add a rule like the following:\n\n```javascript\n// newrelic.js\nexports.config = {\n  // other configuration\n  rules : {\n    ignore : [\n      '^/socket.io/.*/xhr-polling'\n    ]\n  }\n};\n```\n\nThis will keep socket.io long-polling from dominating your response-time\nmetrics and blowing out the apdex metrics for your application.\n\n#### rules.name\n\nA list of rules of the format `{pattern : \"pattern\", name : \"name\"}` for\nmatching incoming request URLs to `pattern` and naming the matching New Relic\ntransactions `name`. When automatically naming rules from the router\nconfiguration, the patterns are still applied to the URL path, and not the name\nreturned by the router. The pattern can be set as either a string or a\nJavaScript regular expression literal. Both pattern and name are required.\nAdditional attributes are ignored.\n\nCan also be set via the environment variable `NEW_RELIC_NAMING_RULES`, with\nmultiple rules passed in as a list of comma-delimited JSON object literals:\n`NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n\n#### rules.ignore\n\nA list of patterns for matching incoming request URLs to be ignored. When using\nignoring rules with instrumented routers, the matches are still made against\nthe URL paths, not the name returned by the router. Patterns may be strings or\nregular expressions.\n\nCan also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with\nmultiple rules passed in as a list of comma-delimited patterns:\n`NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me'` Note that\ncurrently there is no way to escape commas in patterns.\n\n### API for adding naming and ignoring rules\n\n#### newrelic.addNamingRule(pattern, name)\n\nProgrammatic version of `rules.name` above. Naming rules can not be removed\nuntil the Node process is restarted. They can also be added via the module's\nconfiguration. Both parameters are mandatory.\n\n#### newrelic.addIgnoringRule(pattern)\n\nProgrammatic version of `rules.ignore` above. Ignoring rules can not be removed\nuntil the Node process is restarted. They can also be added via the module's\nconfiguration. The pattern is mandatory.\n\n### Other API calls\n\n#### newrelic.addCustomParameter(name, value)\n\nSet a custom parameter value to be displayed along with the transaction trace\nin the New Relic UI. This must be called within the context of a transaction,\nso it has a place to set the custom parameters. Only displayed in the\ntransaction trace detail view.\n\n#### newrelic.setIgnoreTransaction(ignored)\n\nTell the module explicitly whether or not a given request should be ignored.\nAllows you to explicitly filter out long-polling routes or requests you know\nare going to be time-consuming in an uninteresting way, and also allows you\nto gather metrics for requests that would otherwise be ignored. Note that\nto prevent a transaction from being ignored with this function, you **must**\npass `false` as the parameter – in this case `null` or `undefined` will be\nignored.\n\n#### newrelic.noticeError(error, customParameters)\n\nIf your app is doing its own error handling with domains or try/catch clauses,\nbut you want all of the information about how many errors are coming out of the\napp to be centrally managed, use this call. Unlike most of the calls here, this\nfunction can be used outside of route handlers, but will have additional\ncontext if called from within transaction scope. If custom parameters are\npassed in on an object literal, they will be passed back to New Relic for\ndisplay.\n\n### The fine print\n\nThis is the Node-specific version of New Relic's transaction naming API\ndocumentation. The naming API exists to help us deal with the very real problem\nthat trying to handle too many metrics will make New Relic slow for everybody,\nnot just the account with too many metrics. If, in conversation with New Relic\nSupport, you see discussion of \"metric explosion\", this is what they're talking\nabout.\n\nWhile we have a variety of strategies for dealing with these issues, the most\nsevere is simply to blacklist offending applications. The main reason for you\nto be careful in using our request-naming tools is to prevent that from\nhappening to your applications. We will do everything in our power to ensure\nthat you have a good experience with New Relic even if your application is\ncausing us trouble, but sometimes this will require manual intervention on the\npart of our team, and this can take a little while.\n\n## Configuring the module\n\nThe module can be tailored to your app's requirements, both from the server and\nvia the newrelic.js configuration file you created. For complete details on\nwhat can be configured, refer to\n[`lib/config.default.js`](https://github.com/newrelic/node-newrelic/blob/master/lib/config.default.js),\nwhich documents the available variables and their default values.\n\nIn addition, for those of you running in PaaS environments like Heroku or\nMicrosoft Azure, all of the configuration variables in `newrelic.js` have\ncounterparts that can be set via environment variables. You can mix and match\nvariables in the configuration file and environment variables freely;\nenvironment variables take precedence.\n\nHere's the list of the most important variables and their values:\n\n* `NEW_RELIC_LICENSE_KEY`: Your New Relic license key. This is a required\n  setting with no default value.\n* `NEW_RELIC_APP_NAME`: The name of this application, for reporting to New\n  Relic's servers. This value can be also be a comma-delimited list of names.\n  This is a required setting with no default value. (NOTE: as a convenience to\n  Azure users, the module will use `APP_POOL_ID` as the application name if\n  it's set, so you can use the name you chose for your Azure Web Server without\n  setting it twice.)\n* `NEW_RELIC_NO_CONFIG_FILE`: Inhibit loading of the configuration file\n  altogether. Use with care. This presumes that all important configuration\n  will be available via environment variables, and some log messages assume\n  that a config file exists.\n* `NEW_RELIC_HOME`: path to the directory in which you've placed newrelic.js.\n* `NEW_RELIC_USE_SSL`: Use SSL for communication with New Relic's servers.\n  Enabled by default.\n* `NEW_RELIC_LOG`: Complete path to the New Relic agent log, including the\n  filename. The agent will shut down the process if it can't create this file,\n  and it creates the log file with the same umask of the process. Setting this\n  to `stdout` will write all logging to stdout, and `stderr` will write all\n  logging to stderr.\n* `NEW_RELIC_LOG_LEVEL`: Logging priority for the New Relic agent. Can be one\n  of `error`, `warn`, `info`, `debug`, or `trace`. `debug` and `trace` are\n  pretty chatty; unless you're helping New Relic figure out irregularities with\n  the module, you're probably best off using `info` or higher.\n\nFor completeness, here's the rest of the list:\n\n* `NEW_RELIC_ENABLED`: Whether or not the agent should run. Good for\n  temporarily disabling the agent while debugging other issues with your code.\n  It doesn't prevent the module from bootstrapping its instrumentation or\n  setting up all its pieces, it just prevents it from starting up or connecting\n  to New Relic's servers. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_ENABLED`: Whether or not to trace errors within\n  your application. Values are `true` or `false`. Defaults to true.\n* `NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES`: Comma-delimited list of HTTP\n  status codes to ignore. Maybe you don't care if payment is required? Ignoring\n  a status code means that the transaction is not renamed to match the code,\n  and the request is not treated as an error by the error collector. Defaults\n  to ignoring 404.\n* `NEW_RELIC_IGNORE_SERVER_CONFIGURATION`: Whether to ignore server-side\n  configuration for this application. Defaults to false.\n* `NEW_RELIC_TRACER_ENABLED`: Whether to collect and submit slow transaction\n  traces to New Relic. Values are `true` or `false`. Defaults to true.\n* `NEW_RELIC_TRACER_THRESHOLD`: Duration (in seconds) at which a transaction\n  trace will count as slow and be sent to New Relic. Can also be set to\n  `apdex_f`, at which point it will set the trace threshold to 4 times the\n  current ApdexT.\n* `NEW_RELIC_APDEX`: Set the initial Apdex tolerating / threshold value in\n  seconds.  This is more often than not set from the server. Defaults to 0.100.\n* `NEW_RELIC_CAPTURE_PARAMS`: Whether to capture request parameters on slow\n  transaction or error traces. Defaults to false.\n* `NEW_RELIC_IGNORED_PARAMS`: Some parameters may contain sensitive values you\n  don't want being sent out of your application. This setting is a\n  comma-delimited list of names of parameters to ignore. Defaults to empty.\n* `NEW_RELIC_NAMING_RULES`: A list of comma-delimited JSON object literals:\n  `NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}'`\n  See the section on request and transaction naming for details. Defaults to\n  empty.\n* `NEW_RELIC_IGNORING_RULES`: A list of comma-delimited patterns:\n  `NEW_RELIC_IGNORING_RULES='^/socket\\.io/.*/xhr-polling,ignore_me'` Note that\n  currently there is no way to escape commas in patterns. Defaults to empty.\n* `NEW_RELIC_TRACER_TOP_N`: Increase this number to increase the diversity of\n  slow transaction traces sent to New Relic. Defaults to 1. See the description\n  in `lib/config.default.js`, as this feature is exceedingly hard to summarize.\n* `NEW_RELIC_HOST`: Hostname for the New Relic collector proxy. You shouldn't\n  need to change this.\n* `NEW_RELIC_PORT`: Port number on which the New Relic collector proxy will be\n  listening. You shouldn't need to change this either.\n* `NEW_RELIC_DEBUG_METRICS`: Whether to collect internal supportability metrics\n  for the agent. Don't mess with this unless New Relic asks you to.\n* `NEW_RELIC_DEBUG_TRACER`: Whether to dump traces of the transaction tracer's\n  internal operation. It's unlikely to be informative unless you're a New Relic\n  Node.js engineer and it has a significant performance cost, so use with care.\n* `NEW_RELIC_BROWSER_MONITOR_ENABLE`: Whether to generate browser timing (RUM) headers or not.\n\n## Security\n\nWe take security (and the protection of your and your users' privacy) very\nseriously. See SECURITY.md for details, but the brief version is that if you\nfeel you've found a security issue in New Relic for Node, contact us at\nsecurity@newrelic.com.\n\n## Contributions\n\nWe owe a debt to all of the beta testers and users who have provided us with\nfeedback, and in some cases significant pieces of code. (If you wish to\ncontribute, please see CONTRIBUTING.md in this directory.) In particular, we're\nindebted to these people:\n\n* Hernan Silberman, for his work on the memcached instrumentation.\n* Jeff Howell &lt;jhowell@kabam.com&gt;, for coming up with a much simpler way\n  to instrument node-mongodb-native, as well as pointing out a problem with the\n  Connect instrumentation.\n\n## Recent changes\n\nInformation about changes to the module are in NEWS.md.\n\n### Known issues:\n\n* New Relic for Node is only supported on Node.js 0.8 and newer. Some features\n  may behave differently between 0.8, 0.10 and 0.11 / 0.12. The agent is\n  optimized for newer versions of Node.\n* There are irregularities around transaction trace capture and display.  If\n  you notice missing or incorrect information from transaction traces, let us\n  know.\n* There are <del>over 20,000</del> <del>30,000</del> <del>40,000</del> <ins>*A\n  LOT* of</ins> modules on npm. We can only instrument a tiny number of them.\n  Even for the modules we support, there are a very large number of ways to use\n  them. If you see data you don't expect on New Relic and have the time to\n  produce a reduced version of the code that is producing the strange data, it\n  will be used to improve the module and you will have the Node team's\n  gratitude.\n* The CPU and memory overhead incurred by New Relic for Node is relatively\n  minor (~1-10%, depending on how much of the instrumentation your apps end up\n  using).  GC activity is significantly increased while the agent is active,\n  due to the large number of ephemeral objects created by metrics gathering.\n* When using Node's included clustering support, each worker process will open\n  its own connection to New Relic's servers, and will incur its own overhead\n  costs.\n\n### New Relic features available for other platforms not yet in Node.js\n\n* cross-application tracing (depends on RUM)\n* custom metrics and instrumentation\n* slow SQL traces and explain plans\n* garbage collector instrumentation\n* thread profiling\n* X-ray transactions (depends on thread profiling)\n* capacity planning\n\n## LICENSE\n\nNew Relic for Node is free-to-use, proprietary software. Please see the full\nlicense (found in LICENSE in this distribution) for details on its license and\nthe licenses of its dependencies.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/newrelic/node-newrelic/issues"
  },
  "bundleDependencies": [
    "bunyan",
    "continuation-local-storage",
    "yakaa"
  ],
  "_id": "newrelic@1.8.0",
  "dist": {
    "shasum": "863ed5697ba7cf49e4b0951b6db7b418c7880ee0"
  },
  "_from": "newrelic@",
  "_resolved": "https://registry.npmjs.org/newrelic/-/newrelic-1.8.0.tgz"
}
